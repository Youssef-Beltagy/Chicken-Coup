00001000 Starting Address
Assembler used: EASy68K Editor/Assembler v5.16.01
Created On: 10/26/2020 12:28:57 AM

00000000                             1  *-----------------------------------------------------------
00000000                             2  * Title      : Disassembler
00000000                             3  * Written by : Youssef Beltagy
00000000                             4  * Date       : 10/25/2020
00000000                             5  * Description: A 68k Disassembler
00000000                             6  *-----------------------------------------------------------
00001000                             7      ORG    $1000
00001000                             8  START:                  ; first instruction of program
00001000                             9  
00001000                            10  * FIXME: For Testing, DELETE LATER *============================
00001000  4E71                      11      nop *
00001002  4E71                      12      nop *
00001004  4E71                      13      nop *
00001006  4E71                      14      nop *
00001008                            15  * FIXME: For Testing, DELETE LATER *============================
00001008                            16  
00001008  4EB9 0000108C             17      jsr         INPUT_OR_EXIT
0000100E  BEBC FFFFFFFF             18      cmp.l       #-1,d7
00001014  6700 0066                 19      beq         EXIT_PROGRAM
00001018                            20  
00001018                            21  * FIXME: For Testing, DELETE LATER *============================
00001018                            22      *prints the two hex digits
00001018  2239 0000125E             23      move.l      INPUT_START,d1 *
0000101E  103C 000F                 24      move.b      #15,d0 *
00001022  143C 0010                 25      move.b      #16,d2 *
00001026  4E4F                      26      trap        #15 *
00001028                            27      
00001028                            28      *starts a new line
00001028  43F9 000012F0             29      lea         LINE_END,a1 *
0000102E  103C 000E                 30      move.b      #14,d0 *
00001032  4E4F                      31      trap        #15 *
00001034                            32  
00001034  2239 00001262             33      move.l      INPUT_END,d1 *
0000103A  103C 000F                 34      move.b      #15,d0 *
0000103E  143C 0010                 35      move.b      #16,d2 *
00001042  4E4F                      36      trap        #15 * 
00001044                            37  
00001044                            38      *starts a new line
00001044  43F9 000012F0             39      lea         LINE_END,a1 *
0000104A  103C 000E                 40      move.b      #14,d0 *
0000104E  4E4F                      41      trap        #15 *
00001050                            42  
00001050                            43  * FIXME: For Testing, DELETE LATER *============================
00001050                            44  
00001050                            45  
00001050                            46  *TODO: IMPlement a subroutine for the loop if necessary
00001050                            47  
00001050                            48      *The Main Loop
00001050  2C79 0000125E             49      movea.l     INPUT_START,a6
00001056                            50  
00001056                            51  MAIN_LOOP:
00001056  BDF9 00001262             52      cmp.l       INPUT_END,a6
0000105C  6E00 001E                 53      BGT         EXIT_PROGRAM
00001060  43F9 000011AA             54      lea         BUFFER,a1
00001066                            55  
00001066                            56      *Inclusive of INPUT_END TODO: ASK the professor whether it should be inclusive or not
00001066                            57      *Will read the op-code starting at INPUT_END
00001066                            58      *That op-code could be 80 bytes, and there won't be a problem.
00001066                            59  
00001066  0C56 4E71                 60      cmp.w       #$4E71,(a6)
0000106A  6600 0008                 61      bne         SKIP_NOPROUTINE
0000106E  4EB9 00001198             62      jsr         NOPROUTINE
00001074                            63  
00001074                            64  SKIP_NOPROUTINE
00001074                            65      
00001074                            66      *TODO: Implement the window that waits
00001074                            67      * for the user to press enter before it shows more lines
00001074                            68      * of disassembled code
00001074                            69  
00001074                            70      *TODO: Possibly add error checking before you print
00001074  103C 000E                 71      move.b      #14,d0
00001078  4E4F                      72      trap        #15
0000107A  60DA                      73      bra         MAIN_LOOP
0000107C                            74  
0000107C                            75  EXIT_PROGRAM:
0000107C  43F9 000012AB             76      lea         TERMINATION_MESSAGE,a1
00001082  103C 000E                 77      move.b      #14,d0
00001086  4E4F                      78      trap        #15
00001088                            79          
00001088  FFFF FFFF                 80      SIMHALT             ; halt simulator
0000108C                            81  
0000108C                            82  * Utility Subroutines
0000108C                            83  *-----------------------------------------------------------
0000108C                            84  * Put your utility subroutines here
0000108C                            85  
0000108C                            86  INPUT_OR_EXIT:
0000108C                            87  *Description:
0000108C                            88  *Ensures that INPUT_START and INPUT_END
0000108C                            89  *contain valid starting and ending addresses
0000108C                            90  *or returns -1 if the program should terminate.
0000108C                            91  *The addresses are valid if INPUT_END >= INPUT_START
0000108C                            92  *sets d7 to 0 for valid input and to -1 for exit.
0000108C                            93  *Nothing changes other than INPUT_START, INPUT_END, and d7
0000108C                            94  *Input: nothing
0000108C                            95  *Output: d7.l
0000108C  48E7 FEFE                 96      movem.l     d0-d6/a0-a6,-(sp)
00001090                            97  
00001090                            98  INPUT_OR_EXIT_LOOP:
00001090                            99      *prompts for input
00001090  43F9 0000126D            100      lea         INPUT_START_MESSAGE,a1
00001096  103C 000E                101      move.b      #14,d0
0000109A  4E4F                     102      trap        #15
0000109C                           103  
0000109C                           104      *get the input
0000109C  43F9 000011AA            105      lea         BUFFER,a1
000010A2  103C 0002                106      move.b      #2,d0
000010A6  4E4F                     107      trap        #15
000010A8                           108  
000010A8                           109      *If the size of the string is less than 1
000010A8  B27C 0001                110      cmp.w       #1,d1
000010AC  6D00 005E                111      blt         INPUT_OR_EXIT_INVALID
000010B0                           112  
000010B0                           113      *program termination value
000010B0  0C11 0071                114      cmp.b       #113,(a1) *113 is for 'q'
000010B4  6700 0066                115      beq         INPUT_OR_EXIT_TERMINATE *return error code
000010B8                           116  
000010B8                           117      *convert the string into a long
000010B8  4EB9 00001124            118      jsr         LONG_FROM_STRING
000010BE  BEBC FFFFFFFF            119      cmp.l       #-1,d7
000010C4  6700 0046                120      beq         INPUT_OR_EXIT_INVALID  
000010C8                           121  
000010C8                           122      *copy the input
000010C8  23C6 0000125E            123      move.l      d6,INPUT_START
000010CE                           124      
000010CE                           125      *prompt for input
000010CE  43F9 0000128D            126      lea         INPUT_END_MESSAGE,a1
000010D4  103C 000E                127      move.b      #14,d0
000010D8  4E4F                     128      trap        #15
000010DA                           129  
000010DA                           130      *get the input
000010DA  43F9 000011AA            131      lea         BUFFER,a1
000010E0  103C 0002                132      move.b      #2,d0
000010E4  4E4F                     133      trap        #15
000010E6                           134  
000010E6                           135      *convert the string into a long
000010E6  4EB9 00001124            136      jsr         LONG_FROM_STRING
000010EC  BEBC FFFFFFFF            137      cmp.l       #-1,d7
000010F2  6700 0018                138      beq         INPUT_OR_EXIT_INVALID
000010F6                           139  
000010F6                           140      *copy the input
000010F6  23C6 00001262            141      move.l      d6,INPUT_END
000010FC                           142  
000010FC                           143      *Check the validity of the addresses
000010FC  BCB9 0000125E            144      cmp.l       INPUT_START,d6
00001102  6F00 0008                145      ble         INPUT_OR_EXIT_INVALID
00001106                           146      *TODO: Print a unique message when the end address is 
00001106                           147      * is smaller than the start address
00001106                           148  
00001106                           149      *set the error flag to 0
00001106  7E00                     150      move.l      #0,d7
00001108                           151  
00001108                           152      *end the subroutine
00001108  6000 0014                153      bra         INPUT_OR_EXIT_END
0000110C                           154  
0000110C                           155  INPUT_OR_EXIT_INVALID:
0000110C                           156      *prints invalid message
0000110C                           157      *and prompts for input again
0000110C  43F9 000012BE            158      lea         INVALID_MESSAGE,a1
00001112  103C 000E                159      move.b      #14,d0
00001116  4E4F                     160      trap        #15
00001118  6000 FF76                161      bra         INPUT_OR_EXIT_LOOP
0000111C                           162  
0000111C                           163  INPUT_OR_EXIT_TERMINATE:
0000111C  7EFF                     164      move.l      #-1,d7
0000111E                           165  INPUT_OR_EXIT_END:
0000111E  4CDF 7F7F                166      movem.l     (sp)+,d0-d6/a0-a6
00001122  4E75                     167      rts
00001124                           168  * End of INPUT_OR_EXIT
00001124                           169  
00001124                           170  
00001124                           171  LONG_FROM_STRING:
00001124                           172  *Description:
00001124                           173  *Given a string at a1 and its size at d1.w, returns a hex number at 
00001124                           174  *d6 and 0 at d7.l, or -1 at d7.l to represent an error.
00001124                           175  *nothing other than d7 and d6 will change
00001124                           176  *Input: a1, d1.w
00001124                           177  *Output: d7.l, d6.l
00001124                           178  
00001124  48E7 FCFE                179      movem.l     d0-d5/a0-a6,-(sp)
00001128                           180  
00001128                           181      * The default value of d7
00001128                           182      * is 0.
00001128                           183      * If the program returns -1
00001128                           184      * there was an error
00001128  7E00                     185      move.l  #0,d7
0000112A                           186  
0000112A  B27C 0008                187      cmp.w   #8,d1
0000112E  6600 0060                188      BNE     LONG_FROM_STRING_ERROR *The string is too big
00001132                           189      
00001132                           190  
00001132  7C00                     191      move.l  #0,d6
00001134  7008                     192      move.l  #8,d0
00001136                           193  
00001136                           194  LONG_FROM_STRING_LOOP:
00001136  B03C 0000                195      cmp.b   #0,d0
0000113A  6700 0056                196      beq     LONG_FROM_STRING_END
0000113E                           197  
0000113E  7200                     198      move.l  #0,d1
00001140  1219                     199      move.b  (a1)+,d1
00001142                           200  
00001142  B23C 0030                201      cmp.b   #48,d1
00001146  6D00 0048                202      blt     LONG_FROM_STRING_ERROR
0000114A  B23C 003A                203      cmp.b   #58,d1 * '0'-'9' are 48-57
0000114E  6D00 002E                204      blt     LONG_FROM_STRING_DIGIT
00001152  B23C 0041                205      cmp.b   #65,d1
00001156  6D00 0038                206      blt     LONG_FROM_STRING_ERROR
0000115A  B23C 0047                207      cmp.b   #71,d1 * 'A'-'F' are 65-70
0000115E  6D00 0024                208      blt     LONG_FROM_STRING_CAPITAL_CHAR
00001162  B23C 0061                209      cmp.b   #97,d1
00001166  6D00 0028                210      blt     LONG_FROM_STRING_ERROR
0000116A  B23C 0067                211      cmp.b   #103,d1 * 'a'-'f' are 65-70
0000116E  6D00 001A                212      blt     LONG_FROM_STRING_SMALL_CHAR
00001172  6000 001C                213      bra     LONG_FROM_STRING_ERROR
00001176                           214  
00001176                           215  LONG_FROM_STRING_LOOP_CONTINUE:
00001176  E98E                     216      lsl.l   #4,d6
00001178  DC81                     217      add.l   d1,d6
0000117A  5300                     218      sub.b   #1,d0
0000117C  60B8                     219      bra     LONG_FROM_STRING_LOOP
0000117E                           220  
0000117E                           221  LONG_FROM_STRING_DIGIT:
0000117E                           222      *map 48-57 to 0-9
0000117E  0401 0030                223      sub.b   #48,d1
00001182  60F2                     224      bra     LONG_FROM_STRING_LOOP_CONTINUE
00001184                           225  
00001184                           226  LONG_FROM_STRING_CAPITAL_CHAR:
00001184                           227      *map 65-70 to 10-15
00001184  0401 0037                228      sub.b   #55,d1
00001188  60EC                     229      bra     LONG_FROM_STRING_LOOP_CONTINUE
0000118A                           230  
0000118A                           231  LONG_FROM_STRING_SMALL_CHAR:
0000118A                           232      *map 97-102 to 10-15
0000118A  0401 0057                233      sub.b   #87,d1
0000118E  60E6                     234      bra     LONG_FROM_STRING_LOOP_CONTINUE
00001190                           235  
00001190                           236  LONG_FROM_STRING_ERROR:
00001190  7EFF                     237      move.l      #-1,d7
00001192                           238  
00001192                           239  LONG_FROM_STRING_END:
00001192  4CDF 7F3F                240      movem.l     (sp)+,d0-d5/a0-a6
00001196  4E75                     241      rts
00001198                           242  * End of LONG_FROM_STRING subroutine
00001198                           243  
00001198                           244  * Op-cdoe Subroutines
00001198                           245  *-----------------------------------------------------------
00001198                           246  * Put your Op-Code Subroutine here
00001198                           247  
00001198                           248  NOPROUTINE:
00001198                           249  *Description:
00001198                           250  *Loads "NOP" into a1 and increments a6 by two bytes
00001198                           251  *input: a6
00001198                           252  *Output: a1,a6
00001198  48E7 FFBC                253      movem.l     A0/A2-A5/D0-D7, -(sp)
0000119C                           254  
0000119C                           255      *THE movem.l is not necessary for this subroutine.
0000119C                           256      *I put it here as an example.
0000119C                           257      *TODO: Delete the movem
0000119C                           258  
0000119C                           259      *TODO: CONSIDER ADDING an error case
0000119C  43F9 00001266            260      lea         NOP_OPCODE,a1
000011A2  548E                     261      adda.l      #2,a6
000011A4                           262  
000011A4                           263  
000011A4                           264  
000011A4  4CDF 3DFF                265      movem.l     (sp)+,A0/A2-A5/D0-D7
000011A8  4E75                     266      rts
000011AA                           267  
000011AA                           268  * You may want to define your constants next to your
000011AA                           269  * subroutines. TODO: delete this comment after others see it.
000011AA                           270  
000011AA                           271  * End of NOPROUTINE subroutine
000011AA                           272  
000011AA                           273  * Variables
000011AA                           274  *-----------------------------------------------------------
000011AA                           275  * Put variables and constants here
000011AA                           276  
000011AA  =0000000D                277  CR          EQU $0D
000011AA  =0000000A                278  LF          EQU $0A
000011AA                           279  
000011AA                           280  BUFFER
000011AA                           281   * an input BUFFER
000011AA                           282      ds.b   180 *A BUFFER of 180 bytes
0000125E                           283  
0000125E                           284  INPUT_START
0000125E                           285      ds.l    1
00001262                           286  
00001262                           287  INPUT_END
00001262                           288      ds.l    1
00001266                           289  
00001266                           290  NOP_OPCODE
00001266= 4E 4F 50 20 0D 0A 00     291      dc.b    'NOP ',CR,LF,0
0000126D                           292  
0000126D                           293  INPUT_START_MESSAGE
0000126D= 50 6C 65 61 73 65 ...    294      dc.b   'Please Enter Starting Address: ',0
0000128D                           295  
0000128D                           296  INPUT_END_MESSAGE
0000128D= 50 6C 65 61 73 65 ...    297      dc.b   'Please Enter Ending Address: ',0
000012AB                           298  
000012AB                           299  TERMINATION_MESSAGE
000012AB= 50 72 6F 67 72 61 ...    300      dc.b    'Program Terminated',0
000012BE                           301  
000012BE                           302  INVALID_MESSAGE
000012BE= 49 6E 76 61 6C 69 ...    303      dc.b    'Invalid input. Input must be 8-digit hex number',CR,LF,0
000012F0                           304      
000012F0                           305  LINE_END
000012F0= 0D 0A 00                 306      dc.b    CR,LF,0
000012F3                           307  
000012F3                           308  
000012F3                           309      END    START        ; last line of source

No errors detected
No warnings generated


SYMBOL TABLE INFORMATION
Symbol-name         Value
-------------------------
BUFFER              11AA
CR                  D
EXIT_PROGRAM        107C
INPUT_END           1262
INPUT_END_MESSAGE   128D
INPUT_OR_EXIT       108C
INPUT_OR_EXIT_END   111E
INPUT_OR_EXIT_INVALID  110C
INPUT_OR_EXIT_LOOP  1090
INPUT_OR_EXIT_TERMINATE  111C
INPUT_START         125E
INPUT_START_MESSAGE  126D
INVALID_MESSAGE     12BE
LF                  A
LINE_END            12F0
LONG_FROM_STRING    1124
LONG_FROM_STRING_CAPITAL_CHAR  1184
LONG_FROM_STRING_DIGIT  117E
LONG_FROM_STRING_END  1192
LONG_FROM_STRING_ERROR  1190
LONG_FROM_STRING_LOOP  1136
LONG_FROM_STRING_LOOP_CONTINUE  1176
LONG_FROM_STRING_SMALL_CHAR  118A
MAIN_LOOP           1056
NOPROUTINE          1198
NOP_OPCODE          1266
SKIP_NOPROUTINE     1074
START               1000
TERMINATION_MESSAGE  12AB
