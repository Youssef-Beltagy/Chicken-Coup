00001000 Starting Address
Assembler used: EASy68K Editor/Assembler v5.16.01
Created On: 10/26/2020 9:27:14 PM

00000000                             1  *-----------------------------------------------------------
00000000                             2  * Title      : Disassembler
00000000                             3  * Written by : Youssef Beltagy
00000000                             4  * Date       : 10/25/2020
00000000                             5  * Description: A 68k Disassembler
00000000                             6  *-----------------------------------------------------------
00001000                             7      ORG    $1000
00001000                             8  START:                  ; first instruction of program
00001000                             9  
00001000                            10  * FIXME: For Testing, DELETE LATER *============================
00001000  4E71                      11      nop *
00001002  4E71                      12      nop *
00001004  4E71                      13      nop *
00001006  4E71                      14      nop *
00001008                            15  * FIXME: For Testing, DELETE LATER *============================
00001008                            16  
00001008  4EB9 00001090             17      jsr         INPUT_OR_EXIT
0000100E  BEBC FFFFFFFF             18      cmp.l       #-1,d7
00001014  6700 006A                 19      beq         EXIT_PROGRAM
00001018                            20  
00001018                            21  * FIXME: For Testing, DELETE LATER *============================
00001018                            22      *prints the two hex digits
00001018  2239 00001262             23      move.l      INPUT_START,d1 *
0000101E  103C 000F                 24      move.b      #15,d0 *
00001022  143C 0010                 25      move.b      #16,d2 *
00001026  4E4F                      26      trap        #15 *
00001028                            27      
00001028                            28      *starts a new line
00001028  43F9 000012F4             29      lea         LINE_END,a1 *
0000102E  103C 000E                 30      move.b      #14,d0 *
00001032  4E4F                      31      trap        #15 *
00001034                            32  
00001034  2239 00001266             33      move.l      INPUT_END,d1 *
0000103A  103C 000F                 34      move.b      #15,d0 *
0000103E  143C 0010                 35      move.b      #16,d2 *
00001042  4E4F                      36      trap        #15 * 
00001044                            37  
00001044                            38      *starts a new line
00001044  43F9 000012F4             39      lea         LINE_END,a1 *
0000104A  103C 000E                 40      move.b      #14,d0 *
0000104E  4E4F                      41      trap        #15 *
00001050                            42  
00001050                            43  * FIXME: For Testing, DELETE LATER *============================
00001050                            44  
00001050                            45  
00001050                            46  *TODO: IMPlement a subroutine for the loop if necessary
00001050                            47  
00001050                            48      *The Main Loop
00001050  2C79 00001262             49      movea.l     INPUT_START,a6
00001056                            50  
00001056                            51  MAIN_LOOP:
00001056  BDF9 00001266             52      cmp.l       INPUT_END,a6
0000105C  6E00 0022                 53      BGT         EXIT_PROGRAM
00001060  43F9 000011AE             54      lea         BUFFER,a1
00001066                            55  
00001066                            56      *Inclusive of INPUT_END TODO: ASK the professor whether it should be inclusive or not
00001066                            57      *Will read the op-code starting at INPUT_END
00001066                            58      *That op-code could be 80 bytes, and there won't be a problem.
00001066                            59  
00001066  0C56 4E71                 60      cmp.w       #$4E71,(a6)
0000106A  6600 000C                 61      bne         SKIP_NOPROUTINE
0000106E  4EB9 0000119C             62      jsr         NOPROUTINE
00001074  6000 0002                 63      bra         MAIN_LOOP_PRINT
00001078                            64  SKIP_NOPROUTINE:
00001078                            65  
00001078                            66  
00001078                            67  *put more op-code subroutine calls here.
00001078                            68  *Just like NOPROUTINE
00001078                            69  
00001078                            70  
00001078                            71  MAIN_LOOP_PRINT:
00001078                            72      *TODO: Implement the window that waits
00001078                            73      * for the user to press enter before it shows more lines
00001078                            74      * of disassembled code
00001078                            75      *TODO: Possibly add error checking before you print
00001078  103C 000E                 76      move.b      #14,d0
0000107C  4E4F                      77      trap        #15
0000107E  60D6                      78      bra         MAIN_LOOP
00001080                            79  
00001080                            80  EXIT_PROGRAM:
00001080  43F9 000012AF             81      lea         TERMINATION_MESSAGE,a1
00001086  103C 000E                 82      move.b      #14,d0
0000108A  4E4F                      83      trap        #15
0000108C                            84          
0000108C  FFFF FFFF                 85      SIMHALT             ; halt simulator
00001090                            86  
00001090                            87  * Utility Subroutines
00001090                            88  *-----------------------------------------------------------
00001090                            89  * Put your utility subroutines here
00001090                            90  
00001090                            91  INPUT_OR_EXIT:
00001090                            92  *Description:
00001090                            93  *Ensures that INPUT_START and INPUT_END
00001090                            94  *contain valid starting and ending addresses
00001090                            95  *or returns -1 if the program should terminate.
00001090                            96  *The addresses are valid if INPUT_END >= INPUT_START
00001090                            97  *sets d7 to 0 for valid input and to -1 for exit.
00001090                            98  *Nothing changes other than INPUT_START, INPUT_END, and d7
00001090                            99  *Input: nothing
00001090                           100  *Output: d7.l
00001090  48E7 FEFE                101      movem.l     d0-d6/a0-a6,-(sp)
00001094                           102  
00001094                           103  INPUT_OR_EXIT_LOOP:
00001094                           104      *prompts for input
00001094  43F9 00001271            105      lea         INPUT_START_MESSAGE,a1
0000109A  103C 000E                106      move.b      #14,d0
0000109E  4E4F                     107      trap        #15
000010A0                           108  
000010A0                           109      *get the input
000010A0  43F9 000011AE            110      lea         BUFFER,a1
000010A6  103C 0002                111      move.b      #2,d0
000010AA  4E4F                     112      trap        #15
000010AC                           113  
000010AC                           114      *If the size of the string is less than 1
000010AC  B27C 0001                115      cmp.w       #1,d1
000010B0  6D00 005E                116      blt         INPUT_OR_EXIT_INVALID
000010B4                           117  
000010B4                           118      *program termination value
000010B4  0C11 0071                119      cmp.b       #113,(a1) *113 is for 'q'
000010B8  6700 0066                120      beq         INPUT_OR_EXIT_TERMINATE *return error code
000010BC                           121  
000010BC                           122      *convert the string into a long
000010BC  4EB9 00001128            123      jsr         LONG_FROM_STRING
000010C2  BEBC FFFFFFFF            124      cmp.l       #-1,d7
000010C8  6700 0046                125      beq         INPUT_OR_EXIT_INVALID  
000010CC                           126  
000010CC                           127      *copy the input
000010CC  23C6 00001262            128      move.l      d6,INPUT_START
000010D2                           129      
000010D2                           130      *prompt for input
000010D2  43F9 00001291            131      lea         INPUT_END_MESSAGE,a1
000010D8  103C 000E                132      move.b      #14,d0
000010DC  4E4F                     133      trap        #15
000010DE                           134  
000010DE                           135      *get the input
000010DE  43F9 000011AE            136      lea         BUFFER,a1
000010E4  103C 0002                137      move.b      #2,d0
000010E8  4E4F                     138      trap        #15
000010EA                           139  
000010EA                           140      *convert the string into a long
000010EA  4EB9 00001128            141      jsr         LONG_FROM_STRING
000010F0  BEBC FFFFFFFF            142      cmp.l       #-1,d7
000010F6  6700 0018                143      beq         INPUT_OR_EXIT_INVALID
000010FA                           144  
000010FA                           145      *copy the input
000010FA  23C6 00001266            146      move.l      d6,INPUT_END
00001100                           147  
00001100                           148      *Check the validity of the addresses
00001100  BCB9 00001262            149      cmp.l       INPUT_START,d6
00001106  6F00 0008                150      ble         INPUT_OR_EXIT_INVALID
0000110A                           151      *TODO: Print a unique message when the end address is 
0000110A                           152      * is smaller than the start address
0000110A                           153  
0000110A                           154      *set the error flag to 0
0000110A  7E00                     155      move.l      #0,d7
0000110C                           156  
0000110C                           157      *end the subroutine
0000110C  6000 0014                158      bra         INPUT_OR_EXIT_END
00001110                           159  
00001110                           160  INPUT_OR_EXIT_INVALID:
00001110                           161      *prints invalid message
00001110                           162      *and prompts for input again
00001110  43F9 000012C2            163      lea         INVALID_MESSAGE,a1
00001116  103C 000E                164      move.b      #14,d0
0000111A  4E4F                     165      trap        #15
0000111C  6000 FF76                166      bra         INPUT_OR_EXIT_LOOP
00001120                           167  
00001120                           168  INPUT_OR_EXIT_TERMINATE:
00001120  7EFF                     169      move.l      #-1,d7
00001122                           170  INPUT_OR_EXIT_END:
00001122  4CDF 7F7F                171      movem.l     (sp)+,d0-d6/a0-a6
00001126  4E75                     172      rts
00001128                           173  * End of INPUT_OR_EXIT
00001128                           174  
00001128                           175  
00001128                           176  LONG_FROM_STRING:
00001128                           177  *Description:
00001128                           178  *Given a string at a1 and its size at d1.w, returns a hex number at 
00001128                           179  *d6 and 0 at d7.l, or -1 at d7.l to represent an error.
00001128                           180  *nothing other than d7 and d6 will change
00001128                           181  *Input: a1, d1.w
00001128                           182  *Output: d7.l, d6.l
00001128                           183  
00001128  48E7 FCFE                184      movem.l     d0-d5/a0-a6,-(sp)
0000112C                           185  
0000112C                           186      * The default value of d7
0000112C                           187      * is 0.
0000112C                           188      * If the program returns -1
0000112C                           189      * there was an error
0000112C  7E00                     190      move.l  #0,d7
0000112E                           191  
0000112E  B27C 0008                192      cmp.w   #8,d1
00001132  6600 0060                193      BNE     LONG_FROM_STRING_ERROR *The string is too big
00001136                           194      
00001136                           195  
00001136  7C00                     196      move.l  #0,d6
00001138  7008                     197      move.l  #8,d0
0000113A                           198  
0000113A                           199  LONG_FROM_STRING_LOOP:
0000113A  B03C 0000                200      cmp.b   #0,d0
0000113E  6700 0056                201      beq     LONG_FROM_STRING_END
00001142                           202  
00001142  7200                     203      move.l  #0,d1
00001144  1219                     204      move.b  (a1)+,d1
00001146                           205  
00001146  B23C 0030                206      cmp.b   #48,d1
0000114A  6D00 0048                207      blt     LONG_FROM_STRING_ERROR
0000114E  B23C 003A                208      cmp.b   #58,d1 * '0'-'9' are 48-57
00001152  6D00 002E                209      blt     LONG_FROM_STRING_DIGIT
00001156  B23C 0041                210      cmp.b   #65,d1
0000115A  6D00 0038                211      blt     LONG_FROM_STRING_ERROR
0000115E  B23C 0047                212      cmp.b   #71,d1 * 'A'-'F' are 65-70
00001162  6D00 0024                213      blt     LONG_FROM_STRING_CAPITAL_CHAR
00001166  B23C 0061                214      cmp.b   #97,d1
0000116A  6D00 0028                215      blt     LONG_FROM_STRING_ERROR
0000116E  B23C 0067                216      cmp.b   #103,d1 * 'a'-'f' are 65-70
00001172  6D00 001A                217      blt     LONG_FROM_STRING_SMALL_CHAR
00001176  6000 001C                218      bra     LONG_FROM_STRING_ERROR
0000117A                           219  
0000117A                           220  LONG_FROM_STRING_LOOP_CONTINUE:
0000117A  E98E                     221      lsl.l   #4,d6
0000117C  DC81                     222      add.l   d1,d6
0000117E  5300                     223      sub.b   #1,d0
00001180  60B8                     224      bra     LONG_FROM_STRING_LOOP
00001182                           225  
00001182                           226  LONG_FROM_STRING_DIGIT:
00001182                           227      *map 48-57 to 0-9
00001182  0401 0030                228      sub.b   #48,d1
00001186  60F2                     229      bra     LONG_FROM_STRING_LOOP_CONTINUE
00001188                           230  
00001188                           231  LONG_FROM_STRING_CAPITAL_CHAR:
00001188                           232      *map 65-70 to 10-15
00001188  0401 0037                233      sub.b   #55,d1
0000118C  60EC                     234      bra     LONG_FROM_STRING_LOOP_CONTINUE
0000118E                           235  
0000118E                           236  LONG_FROM_STRING_SMALL_CHAR:
0000118E                           237      *map 97-102 to 10-15
0000118E  0401 0057                238      sub.b   #87,d1
00001192  60E6                     239      bra     LONG_FROM_STRING_LOOP_CONTINUE
00001194                           240  
00001194                           241  LONG_FROM_STRING_ERROR:
00001194  7EFF                     242      move.l      #-1,d7
00001196                           243  
00001196                           244  LONG_FROM_STRING_END:
00001196  4CDF 7F3F                245      movem.l     (sp)+,d0-d5/a0-a6
0000119A  4E75                     246      rts
0000119C                           247  * End of LONG_FROM_STRING subroutine
0000119C                           248  
0000119C                           249  * Op-cdoe Subroutines
0000119C                           250  *-----------------------------------------------------------
0000119C                           251  * Put your Op-Code Subroutine here
0000119C                           252  
0000119C                           253  NOPROUTINE:
0000119C                           254  *Description:
0000119C                           255  *Loads "NOP" into a1 and increments a6 by two bytes
0000119C                           256  *input: a6
0000119C                           257  *Output: a1,a6
0000119C  48E7 FFBC                258      movem.l     A0/A2-A5/D0-D7, -(sp)
000011A0                           259  
000011A0                           260      *THE movem.l is not necessary for this subroutine.
000011A0                           261      *I put it here as an example.
000011A0                           262      *TODO: Delete the movem
000011A0                           263  
000011A0                           264      *TODO: CONSIDER ADDING an error case
000011A0  43F9 0000126A            265      lea         NOP_OPCODE,a1
000011A6  548E                     266      adda.l      #2,a6
000011A8                           267  
000011A8                           268  
000011A8                           269  
000011A8  4CDF 3DFF                270      movem.l     (sp)+,A0/A2-A5/D0-D7
000011AC  4E75                     271      rts
000011AE                           272  
000011AE                           273  * You may want to define your constants next to your
000011AE                           274  * subroutines. TODO: delete this comment after others see it.
000011AE                           275  
000011AE                           276  * End of NOPROUTINE subroutine
000011AE                           277  
000011AE                           278  * Variables
000011AE                           279  *-----------------------------------------------------------
000011AE                           280  * Put variables and constants here
000011AE                           281  
000011AE  =0000000D                282  CR          EQU $0D
000011AE  =0000000A                283  LF          EQU $0A
000011AE                           284  
000011AE                           285  BUFFER
000011AE                           286   * an input BUFFER
000011AE                           287      ds.b   180 *A BUFFER of 180 bytes
00001262                           288  
00001262                           289  INPUT_START
00001262                           290      ds.l    1
00001266                           291  
00001266                           292  INPUT_END
00001266                           293      ds.l    1
0000126A                           294  
0000126A                           295  NOP_OPCODE
0000126A= 4E 4F 50 20 0D 0A 00     296      dc.b    'NOP ',CR,LF,0
00001271                           297  
00001271                           298  INPUT_START_MESSAGE
00001271= 50 6C 65 61 73 65 ...    299      dc.b   'Please Enter Starting Address: ',0
00001291                           300  
00001291                           301  INPUT_END_MESSAGE
00001291= 50 6C 65 61 73 65 ...    302      dc.b   'Please Enter Ending Address: ',0
000012AF                           303  
000012AF                           304  TERMINATION_MESSAGE
000012AF= 50 72 6F 67 72 61 ...    305      dc.b    'Program Terminated',0
000012C2                           306  
000012C2                           307  INVALID_MESSAGE
000012C2= 49 6E 76 61 6C 69 ...    308      dc.b    'Invalid input. Input must be 8-digit hex number',CR,LF,0
000012F4                           309      
000012F4                           310  LINE_END
000012F4= 0D 0A 00                 311      dc.b    CR,LF,0
000012F7                           312  
000012F7                           313  
000012F7                           314      END    START        ; last line of source

No errors detected
No warnings generated


SYMBOL TABLE INFORMATION
Symbol-name         Value
-------------------------
BUFFER              11AE
CR                  D
EXIT_PROGRAM        1080
INPUT_END           1266
INPUT_END_MESSAGE   1291
INPUT_OR_EXIT       1090
INPUT_OR_EXIT_END   1122
INPUT_OR_EXIT_INVALID  1110
INPUT_OR_EXIT_LOOP  1094
INPUT_OR_EXIT_TERMINATE  1120
INPUT_START         1262
INPUT_START_MESSAGE  1271
INVALID_MESSAGE     12C2
LF                  A
LINE_END            12F4
LONG_FROM_STRING    1128
LONG_FROM_STRING_CAPITAL_CHAR  1188
LONG_FROM_STRING_DIGIT  1182
LONG_FROM_STRING_END  1196
LONG_FROM_STRING_ERROR  1194
LONG_FROM_STRING_LOOP  113A
LONG_FROM_STRING_LOOP_CONTINUE  117A
LONG_FROM_STRING_SMALL_CHAR  118E
MAIN_LOOP           1056
MAIN_LOOP_PRINT     1078
NOPROUTINE          119C
NOP_OPCODE          126A
SKIP_NOPROUTINE     1078
START               1000
TERMINATION_MESSAGE  12AF
